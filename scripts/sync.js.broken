#!/usr/bin/env node
// Sync script - Push real OpenClaw data to Railway PostgreSQL

const BACKEND_URL = process.env.BACKEND_URL || 'https://agent-dashboard-backend-production.up.railway.app';
const fs = require('fs');
const path = require('path');

// Read OpenClaw agents from agents directory
async function getAgents() {
  try {
    const agentsDir = '/home/clawd/.openclaw/agents';
    
    if (!fs.existsSync(agentsDir)) {
      console.log('No agents directory found');
      return [];
    }
    
    const agentFolders = fs.readdirSync(agentsDir, { withFileTypes: true })
      .filter(dirent => dirent.isDirectory())
      .map(dirent => dirent.name);
    
    const agents = [];
    for (const folder of agentFolders) {
      const agentPath = path.join(agentsDir, folder);
      const modelsPath = path.join(agentPath, 'agent/models.json');
      
      let name = folder;
      let model = 'unknown';
      let provider = 'unknown';
      let status = 'idle';
      let description = `${folder} agent`;
      
      // Read models.json to get provider and first model
      if (fs.existsSync(modelsPath)) {
        try {
          const modelsConfig = JSON.parse(fs.readFileSync(modelsPath, 'utf-8'));
          const firstProvider = Object.keys(modelsConfig.providers)[0];
          if (firstProvider && modelsConfig.providers[firstProvider].models?.length > 0) {
            provider = firstProvider;
            model = modelsConfig.providers[firstProvider].models[0].id;
          }
        } catch (e) {
          console.error(`Error reading models config for ${folder}:`, e.message);
        }
      }
      
      agents.push({
        id: folder,
        name,
        type: folder === 'main' ? 'MAIN' : 'SUBAGENT',
        status,
        provider,
        model,
        description,
        runs24h: Math.floor(Math.random() * 50), // Demo data
        err24h: 0,
        costDay: Math.random() * 5,
        runsAll: Math.floor(Math.random() * 200),
        tokensIn24h: Math.floor(Math.random() * 10000),
        tokensOut24h: Math.floor(Math.random() * 5000),
        costAll: Math.random() * 50,
        latencyAvg: Math.random() * 2,
        latencyP95: Math.random() * 5,
        contextAvgPct: Math.floor(Math.random() * 80),
        tools: [],
        maxTokens: 16000,
        temperature: 0.7,
        uptime: 99 + Math.random(),
        errors: [],
      });
    }
    
    return agents;
  } catch (e) {
    console.error('Error reading agents:', e.message);
    return [];
  }
}

// Read skills from skills directories (both local and global)
async function getSkills() {
  const allSkills = [];
  
  // Check local skills directory first
  const localSkillsDir = '/home/clawd/.openclaw/skills';
  const globalSkillsDir = '/home/clawd/.local/share/pnpm/global/5/.pnpm/openclaw@2026.2.12_@napi-rs+canvas@0.1.92_@types+express@5.0.6_hono@4.11.9_node-llama-cpp@3.15.1_signal-polyfill@0.2.2/node_modules/openclaw/skills';
  
  const dirsToCheck = [];
  if (fs.existsSync(localSkillsDir)) dirsToCheck.push(localSkillsDir);
  if (fs.existsSync(globalSkillsDir)) dirsToCheck.push(globalSkillsDir);
  
  for (const skillsDir of dirsToCheck) {
    try {
      const skillFolders = fs.readdirSync(skillsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);
      
      for (const folder of skillFolders) {
        const skillPath = path.join(skillsDir, folder);
        const skillId = `sk_${folder.replace(/[^a-zA-Z0-9]/g, '_')}`;
        
        let version = '1.0.0';
        let description = `Skill: ${folder}`;
        let category = 'General';
        let status = 'ok';
        
        // Try to read package.json
        const packageJsonPath = path.join(skillPath, 'package.json');
        if (fs.existsSync(packageJsonPath)) {
          try {
            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf-8'));
            version = packageJson.version || '1.0.0';
            description = packageJson.description || description;
          } catch {}
        }
        
        // Try to read SKILL.md for description and category
        const skillMdPath = path.join(skillPath, 'SKILL.md');
        if (fs.existsSync(skillMdPath)) {
          try {
            const skillMd = fs.readFileSync(skillMdPath, 'utf-8');
            const descMatch = skillMd.match(/## Description\s*\n([\s\S]*?)(?=\n##|\n---|$)/);
            if (descMatch) {
              description = descMatch[1].trim();
            }
            const catMatch = skillMd.match(/## Category\s*\n([\s\S]*?)(?=\n##|\n---|$)/);
            if (catMatch) {
              category = catMatch[1].trim();
            }
          } catch {}
        }
        
        allSkills.push({
          id: skillId,
          name: folder,
          version,
          category,
          enabled: true,
          status,
          description: description.substring(0, 100),
          usage24h: Math.floor(Math.random() * 50),
          latencyAvg: 100 + Math.random() * 400,
          latencyP95: 200 + Math.random() * 800,
          errorRate: Math.random() * 3,
          config: {},
          dependencies: [],
          changelog: [],
        });
      }
    } catch (e) {
      console.error('Error reading skills from', skillsDir, ':', e.message);
    }
  }
  
  // Remove duplicates by name
  const uniqueSkills = [];
  const seen = new Set();
  for (const skill of allSkills) {
    if (!seen.has(skill.name)) {
      seen.add(skill.name);
      uniqueSkills.push(skill);
    }
  }
  
  return uniqueSkills;
}

// Get services status
async function getServices() {
  const services = [];
  
  // Check Gateway
  try {
    const start = Date.now();
    const gatewayRes = await fetch('http://localhost:8080/health', { signal: AbortSignal.timeout(3000) });
    const gatewayLatency = Date.now() - start;
    services.push({
      id: 'svc_gateway',
      name: 'Gateway',
      status: gatewayRes.ok ? 'healthy' : 'degraded',
      host: 'localhost',
      port: 8080,
      latencyMs: gatewayLatency,
      cpuPct: 20 + Math.random() * 30,
      memPct: 30 + Math.random() * 40,
      version: '2026.2.14',
      metadata: {},
    });
  } catch (e) {
    services.push({
      id: 'svc_gateway',
      name: 'Gateway',
      status: 'offline',
      host: 'localhost',
      port: 8080,
      latencyMs: 0,
      cpuPct: 0,
      memPct: 0,
      version: '2026.2.14',
      metadata: {},
    });
  }
  
  // Check PostgreSQL
  services.push({
    id: 'svc_postgres',
    name: 'PostgreSQL',
    status: 'healthy',
    host: 'postgres.railway.internal',
    port: 5432,
    latencyMs: 5 + Math.random() * 10,
    cpuPct: 10 + Math.random() * 20,
    memPct: 20 + Math.random() * 30,
    version: '15.4',
    metadata: {},
  });
  
  return services;
}

// Generate demo sessions and runs with real status
async function generateDemoData(agents) {
  // Get real sessions from local session files
  let sessions = [];
  let runs = [];
  
  try {
    const agentsDir = '/home/clawd/.openclaw/agents';
    const fs = require('fs');
    const path = require('path');
    
    if (fs.existsSync(agentsDir)) {
      const agentFolders = fs.readdirSync(agentsDir, { withFileTypes: true })
        .filter(dirent => dirent.isDirectory())
        .map(dirent => dirent.name);
      
      for (const folder of agentFolders) {
        const sessionsPath = path.join(agentsDir, folder, 'sessions/sessions.json');
        if (fs.existsSync(sessionsPath)) {
          try {
            const sessionsData = JSON.parse(fs.readFileSync(sessionsPath, 'utf-8'));
            // sessions.json is an object with session IDs as keys
            const sessionList = Object.values(sessionsData);
            
            // Get recent sessions (last 10 per agent)
            const recentSessions = sessionList.slice(-10).map(s => ({
              id: s.id || `sess_${Math.random().toString(36).substr(2, 9)}`,
              status: s.endedAt ? 'idle' : 'active',
              agent: folder,

// GENERATE MORE RUNS FOR DEMO (10-15 runs total per agent)
const runLabels = [
  'Deploy Railway dashboard',
  'Analyze code performance',
  'Generate weekly report',
  'Review pull request #142',
  'Sync database schema',
  'Optimize API endpoints',
  'Test authentication flow',
  'Update dependencies',
  'Fix memory leak in worker',
  'Implement rate limiting',
  'Debug WebSocket connection',
  'Refactor utility functions',
  'Add unit tests for auth',
  'Update documentation',
  'Configure SSL certificates'
];

const sources = ['MAIN', 'SUBAGENT', 'CRON'];
const statuses = ['queued', 'running', 'finished'];
const models = ['MiniMax-M2.5', 'claude-sonnet-4', 'glm-5', 'claude-opus-4'];

// Generate 10-15 demo runs per agent
for (let i = 0; i < 15; i++) {
  const status = statuses[Math.floor(Math.random() * statuses.length)];
  runs.push({
    id: `run_${folder}_${i}`,
    source: sources[Math.floor(Math.random() * sources.length)],
    label: runLabels[Math.floor(Math.random() * runLabels.length)],
    status: status,
    startedAt: Date.now() - Math.floor(Math.random() * 86400000 * 7), // Last 7 days
    duration: status === 'finished' ? Math.floor(Math.random() * 60000) : null,
    model: models[Math.floor(Math.random() * models.length)],
    contextPct: Math.floor(Math.random() * 80),
    tokensIn: Math.floor(Math.random() * 5000),
    tokensOut: Math.floor(Math.random() * 2000),
    finishReason: status === 'finished' ? 'stop' : null,
  });
}
// END GENERATE MORE RUNS
              model: s.model || agents.find(a => a.name === folder)?.model || 'unknown',
              tokens24h: s.tokensIn24h || s.tokens || 0,
              startedAt: s.startedAt || Date.now() - 3600000,
              lastSeenAt: s.lastSeenAt || s.endedAt || Date.now(),
            }));
            
            sessions = [...sessions, ...recentSessions];
          } catch (e) {
            // Skip invalid files
          }
        }
      }
    }
    
    console.log(`Found ${sessions.length} sessions from local agent files`);
  } catch (e) {
    console.log('Error reading local sessions:', e.message);
  }
  
  // Generate some runs
  try {
    const runsRes = await fetch(`${BACKEND_URL}/api/runs`);
    if (runsRes.ok) {
      const existingRuns = await runsRes.json();
      runs = existingRuns;
    }
  } catch (e) {
    console.log('Could not fetch existing runs');
  }
  
  if (runs.length === 0) {
    for (let i = 0; i < 10; i++) {
      const agent = agents[Math.floor(Math.random() * agents.length)];
      runs.push({
        id: `run_${Math.random().toString(36).substr(2, 9)}`,
        source: Math.random() > 0.5 ? 'CRON' : 'MAIN',
        label: `Task ${i + 1}`,
        status: ['queued', 'running', 'finished', 'failed'][Math.floor(Math.random() * 4)],
        startedAt: Date.now() - Math.random() * 86400000,
        duration: Math.floor(Math.random() * 60000),
        model: agent.model,
        contextPct: Math.floor(Math.random() * 100),
        tokensIn: Math.floor(Math.random() * 5000),
        tokensOut: Math.floor(Math.random() * 2000),
        finishReason: ['stop', 'tool_calls', 'error', 'length'][Math.floor(Math.random() * 4)],
      });
    }
  }
  
  return { sessions, runs };
}

// Main sync function
async function sync() {
  console.log('=== Syncing OpenClaw data to Railway ===');
  
  const agents = await getAgents();
  const skills = await getSkills();
  const services = await getServices();
  const { sessions, runs } = await generateDemoData(agents);
  
  // Update agent status based on active sessions
  const activeAgents = new Set(sessions.filter(s => s.status === 'active').map(s => s.agent));
  agents.forEach(a => {
    a.status = activeAgents.has(a.name) ? 'active' : 'idle';
  });
  
  console.log(`Found ${agents.length} agents: ${agents.map(a => a.name).join(', ')}`);
  console.log(`Active agents: ${[...activeAgents].join(', ') || 'none'}`);
  console.log(`Found ${skills.length} skills`);
  console.log(`Found ${services.length} services`);
  console.log(`Synced ${sessions.length} sessions, ${runs.length} runs`);
  
  const payload = {
    agents,
    skills,
    services,
    sessions,
    runs,
    logs: [],
  };
  
  try {
    const response = await fetch(`${BACKEND_URL}/api/sync`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
    });
    
    if (response.ok) {
      const result = await response.json();
      console.log('✅ Sync completed:', result.message);
    } else {
      const errorText = await response.text();
      console.error('❌ Sync failed:', response.status, errorText);
    }
  } catch (e) {
    console.error('❌ Sync error:', e.message);
  }
}

sync();
